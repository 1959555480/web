<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>vue</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <script src='vue.js'></script>
</head>
<body>
    <div id="app">
        {{ message }}
        <hr>
        <span v-bind:title="msg"><!-- 缩写为 ：title-->
            走走停停 看看下
        </span>
        <P v-if = "seen">YYX</P>
        <p v-on:[event] = "doSomething">11</p><!--动态参数  浏览器会强制转换小写-->
        <ol>
            <li v-for = "todo in todos">
                {{ todo.text }}
            </li>
            <todo-item
                v-for = "item in groceryList"
                v-bind:todo = "item"
                v-bind:key = "item.id"
            ></todo-item>
        </ol>
        <button v-on:click = "reverseMessage">逆转</button><br><!-- 缩写为 @click-->
        <input v-model = "message">双向绑定
        <div>
            <p>原始: "{{ message }}" </p>
            <p>通过计算属性逆转: "{{ reversedmsg }}"</p>
        </div>
        <div>
                监听属性 {{ fullname }}
                <br>
                计算属性 {{ allfull }}
        </div>
    </div>
    <script>
        Vue.component('todo-item',{//自定义模板
            props: ['todo'],
            template: '<li>{{ todo.text }}</li>'
        })
        
        var app = new Vue({
            el: '#app',
            data: {
                message: "superY日志",
                msg: 'Hello Vue!',
                event: "click",
                seen: true,
                todos:[
                    { text:"学习" },
                    { text:"工作" },
                    { text:"生活" }
                ],
                groceryList:[
                    { id:0, text:"英雄联盟" },
                    { id:1, text:"地下城与勇士" },
                    { id:2, text:"逆水寒" }
                ],
                firstName: 'y',
                lastName: 'yx',
                fullname: 'yyx',
                allfirst: 'yan',
                alllast: 'yongxing'
            },
            methods:{
                reverseMessage: function(){
                    this.message = this.message.split('').reverse().join('')
                },
                doSomething: function(){
                    alert("hei boy")
                }
            },
        // // 我们可以将同一函数定义为一个方法而不是一个计算属性。
        // 两种方式的最终结果确实是完全相同的。
        // 然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。
        // 只在相关响应式依赖发生改变时它们才会重新求值。
        // 这就意味着只要 message 还没有发生改变，
        // 多次访问 reversedMessage 计算属性会立即返回之前的计算结果
        // ，而不必再次执行函数。  
            computed:{
                reversedmsg: function(){
                    return this.message.split('').reverse().join('')
                },
                allfull: function(){
                    return this.allfirst + '' + this.alllast
                }
            },
            watch:{
                firstName: function(val){
                    this.fullNmae = val + '' + this.lastName
                },
                lastName: function(val){
                    this.fullNmae = this.firstName + '' + val
                }
            }
        })
        
    </script>
</body>
</html>